////////////////////////////////////////////////////////////////////////////////
// Подсистема "Базовая функциональность".
// Серверные процедуры и функции общего назначения.
//  
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Возвращает признак наличия в конфигурации общих реквизитов-разделителей.
//
// Возвращаемое значение:
// Булево.
//
Функция ЭтоРазделеннаяКонфигурация() Экспорт
	
	ЕстьРазделители = Ложь;
	Для каждого ОбщийРеквизит Из Метаданные.ОбщиеРеквизиты Цикл
		Если ОбщийРеквизит.РазделениеДанных = Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять Тогда
			ЕстьРазделители = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ЕстьРазделители;
	
КонецФункции

// Возвращает список полных имен всех объектов метаданных, использующихся в общих реквизитах-разделителях.
// Для последовательностей и журналов документов определяет разделенность по входящим документам: любому из.
//
// Возвращаемое значение:
// ФиксированноеСоответствие.
//
Функция РазделенныеОбъектыМетаданных() Экспорт
	
	Результат = Новый Соответствие;
	
	// I. Перебрать состав всех общих реквизитов.
	
	Для Каждого МетаданныеОбщегоРеквизита Из Метаданные.ОбщиеРеквизиты Цикл
		Если МетаданныеОбщегоРеквизита.РазделениеДанных = Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять Тогда
			СоставОбщегоРеквизита = ОбщегоНазначенияПовтИсп.СоставОбщегоРеквизита(МетаданныеОбщегоРеквизита.Имя);
			
			Для Каждого ЭлементСостава Из СоставОбщегоРеквизита Цикл
				
				Если ОбщегоНазначения.ЭлементСоставаОбщегоРеквизитаИспользуется(ЭлементСостава, МетаданныеОбщегоРеквизита) Тогда
					Результат.Вставить(ЭлементСостава.Метаданные.ПолноеИмя(), Истина);
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
	КонецЦикла;
	
	// II. Для последовательностей и журналов определять разделенность по входящим документам.
	
	// 1) Последовательности. Перебор с проверкой первого входящего документа. Если документов нет, считаем разделенной.
	Для Каждого МетаданныеПоследовательности Из Метаданные.Последовательности Цикл
		Если МетаданныеПоследовательности.Документы.Количество() = 0 Тогда
			ШаблонСообщения = НСтр("ru = 'В последовательность %1 не включено ни одного документа.'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, МетаданныеПоследовательности.Имя);
			ЗаписьЖурналаРегистрации("ОбщегоНазначенияПовтИсп.РазделенныеОбъектыМетаданных", УровеньЖурналаРегистрации.Ошибка, 
				МетаданныеПоследовательности, , ТекстСообщения);
			Результат.Вставить(МетаданныеПоследовательности.ПолноеИмя(), Истина);
		Иначе	
			Для Каждого МетаданныеДокумента Из МетаданныеПоследовательности.Документы Цикл
				Если Результат.Получить(МетаданныеДокумента.ПолноеИмя()) <> Неопределено Тогда
					Результат.Вставить(МетаданныеПоследовательности.ПолноеИмя(), Истина);
				КонецЕсли;
				Прервать;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	// 2) Журналы. Перебор с проверкой первого входящего документа. Если документов нет, считаем разделенным.
	Для Каждого МетаданныеЖурналаДокументов Из Метаданные.ЖурналыДокументов Цикл
		Если МетаданныеЖурналаДокументов.РегистрируемыеДокументы.Количество() = 0 Тогда
			ШаблонСообщения = НСтр("ru = 'В журнал %1 не включено ни одного документа.'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, МетаданныеЖурналаДокументов.Имя);
			ЗаписьЖурналаРегистрации("ОбщегоНазначенияПовтИсп.РазделенныеОбъектыМетаданных", УровеньЖурналаРегистрации.Ошибка, 
				МетаданныеЖурналаДокументов, , ТекстСообщения);
			Результат.Вставить(МетаданныеЖурналаДокументов.ПолноеИмя(), Истина);
		Иначе
			Для Каждого МетаданныеДокумента Из МетаданныеЖурналаДокументов.РегистрируемыеДокументы Цикл
				Если Результат.Получить(МетаданныеДокумента.ПолноеИмя()) <> Неопределено Тогда
					Результат.Вставить(МетаданныеЖурналаДокументов.ПолноеИмя(), Истина);
				КонецЕсли;
				Прервать;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый ФиксированноеСоответствие(Результат);
	
КонецФункции

// Возвращает состав общего реквизита с заданным именем.
//
// Параметры:
// Имя - Строка - Имя общего реквизита.
//
// Возвращаемое значение:
// СоставОбщегоРеквизита.
//
Функция СоставОбщегоРеквизита(Знач Имя) Экспорт
	
	Возврат Метаданные.ОбщиеРеквизиты[Имя].Состав;
	
КонецФункции

// Возвращает признак того, что объект метаданных используется в общих реквизитах-разделителях.
//
// Параметры:
// ИмяОбъектаМетаданных - Строка.
//
// Возвращаемое значение:
// Булево.
//
Функция ЭтоРазделенныйОбъектМетаданных(Знач ИмяОбъектаМетаданных) Экспорт
	
	Возврат ОбщегоНазначения.ЭтоРазделенныйОбъектМетаданных(ИмяОбъектаМетаданных);
	
КонецФункции

// Возвращает признак включения условного разделения.
// В случае вызова в неразделенной конфигурации возвращает Ложь.
//
Функция РазделениеВключено() Экспорт
	
	Если НЕ ЭтоРазделеннаяКонфигурация() Тогда
		Возврат Ложь;
	Иначе
		Возврат ПолучитьФункциональнуюОпцию("ИспользоватьРазделениеПоОбластямДанных");
	КонецЕсли;
	
КонецФункции

// Возвращает признак возможности обращения к разделенным данным из текущего сеанса.
// В случае вызова в неразделенной конфигурации возвращает Истина.
//
// Возвращаемое значение:
// Булево.
//
Функция ДоступноИспользованиеРазделенныхДанных() Экспорт
	
	Если НЕ РазделениеВключено() Тогда
		
		Возврат Истина;
	Иначе
		
		УстановитьПривилегированныйРежим(Истина);
		Возврат ОбщегоНазначения.ИспользованиеРазделителяСеанса();
		
	КонецЕсли;
	
КонецФункции

// Функция возвращает объект WSОпределения созданный с переданными параметрами.
//
// Параметры соответствуют конструктору объекта.
//
//
// Примечание: при получении определения используется кэш, обновление которого осуществляется
//  при смене версии конфигурации. Если для целей отладки требуется обновить
//  значения в кэше, раньше этого времени, следует удалить из регистра сведений 
//  КэшПрограммныхИнтерфейсов соответствующие записи.
//
Функция ПолучитьWSОпределения(Знач АдресWSDL, Знач ИмяПользователя, Знач Пароль) Экспорт
	
	ДоступноПолучениеФайловИзИнтернета = Неопределено;
	СтандартныеПодсистемыПереопределяемый.ДоступноПолучениеФайловИзИнтернета(ДоступноПолучениеФайловИзИнтернета);
	Если ДоступноПолучениеФайловИзИнтернета = Истина Тогда
	
		ПараметрыПолучения = Новый Массив;
		ПараметрыПолучения.Добавить(АдресWSDL);
		ПараметрыПолучения.Добавить(ИмяПользователя);
		ПараметрыПолучения.Добавить(Пароль);
		
		ДанныеWSDL = ОбщегоНазначенияПовтИсп.ПолучитьДанныеКэшаВерсий(
			АдресWSDL, 
			Перечисления.ТипыДанныхКэшаПрограммныхИнтерфейсов.ОписаниеWebСервиса, 
			ОбщегоНазначения.ЗначениеВСтрокуXML(ПараметрыПолучения),
			Ложь);
			
		ИмяФайлаWSDL = ПолучитьИмяВременногоФайла("wsdl");
		
		ДанныеWSDL.Записать(ИмяФайлаWSDL);
		
		Определения = Новый WSОпределения(ИмяФайлаWSDL);
		
		Попытка
			УдалитьФайлы(ИмяФайлаWSDL);
		Исключение
			ЗаписьЖурналаРегистрации("УдалениеВременныхФайлов", УровеньЖурналаРегистрации.Ошибка, , , 
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		Возврат Определения;
		
	Иначе
		
		Возврат Новый WSОпределения(АдресWSDL, ИмяПользователя, Пароль);
		
	КонецЕсли;
	
КонецФункции

// Функция возвращает объект WSПрокси созданный с переданными параметрами.
//
// Параметры соответствуют конструктору объекта. См. синтакс-помощник.
//
Функция ПолучитьWSПрокси(Знач АдресWSDL, Знач URIПространстваИмен, Знач ИмяСервиса,
	Знач ИмяТочкиПодключения = "", Знач ИмяПользователя, Знач Пароль) Экспорт
	
	WSОпределения = ОбщегоНазначенияПовтИсп.ПолучитьWSОпределения(АдресWSDL, ИмяПользователя, Пароль);
	
	Если ПустаяСтрока(ИмяТочкиПодключения) Тогда
		ИмяТочкиПодключения = ИмяСервиса + "Soap";
	КонецЕсли;
	
	Прокси = Новый WSПрокси(WSОпределения, URIПространстваИмен, ИмяСервиса, ИмяТочкиПодключения);
	Прокси.Пользователь = ИмяПользователя;
	Прокси.Пароль = Пароль;
	
	Возврат Прокси;
	
КонецФункции

// Возвращает объект ПреобразованиеXSL созданный из общего макета с переданным
// именем.
//
// Параметры:
// ИмяОбщегоМакет - Строка - имя общего макета типа ДвоичныеДанные содержащего
// файл преобразования XSL.
//
// Возвращаемое значение:
// ПреобразвоаниеXSL - объект ПреобразвоаниеXSL с загруженным п
//
Функция ПолучитьПреобразованиеXSLИзОбщегоМакета(Знач ИмяОбщегоМакета) Экспорт
	
	ДанныеМакета = ПолучитьОбщийМакет(ИмяОбщегоМакета);
	ИмяФайлаПреобразования = ПолучитьИмяВременногоФайла("xsl");
	ДанныеМакета.Записать(ИмяФайлаПреобразования);
	
	Преобразование = Новый ПреобразованиеXSL;
	Преобразование.ЗагрузитьИзФайла(ИмяФайлаПреобразования);
	
	Попытка
		УдалитьФайлы(ИмяФайлаПреобразования);
	Исключение
		
	КонецПопытки;
	
	Возврат Преобразование;
	
КонецФункции

// Определяет, сеанс запущен с разделителями или без.
//
// Возвращаемое значение:
// Булево.
//
Функция СеансЗапущенБезРазделителей() Экспорт
	
	Возврат ПользователиИнформационнойБазы.ТекущийПользователь().РазделениеДанных.Количество() = 0;
	
КонецФункции

// Возвращает тип платформы сервера.
//
// Возвращаемое значение:
// ТипПлатформы; Неопределено.
//
Функция ТипПлатформыСервера() Экспорт
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	Возврат СистемнаяИнфо.ТипПлатформы;
	
КонецФункции	

// Функция получает цвет стиля по имени элемента стиля
//
// Параметры:
// ИмяЦветаСтиля - Строка -  Имя элемента стиля.
//
// Возвращаемое значение:
// Цвет.
//
Функция ЦветСтиля(ИмяЦветаСтиля) Экспорт
	
	Возврат ЦветаСтиля[ИмяЦветаСтиля];
	
КонецФункции

// Функция получает шрифт стиля по имени элемента стиля.
//
// Параметры:
// ИмяШрифтаСтиля - Строка - Имя шрифта стиля.
//
// Возвращаемое значение:
// Шрифт.
//
Функция ШрифтСтиля(ИмяШрифтаСтиля) Экспорт
	
	Возврат ШрифтыСтиля[ИмяШрифтаСтиля];
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Функция получает данные кеша версий из ресурса типа ХранилищеЗначения регистра КэшПрограммныхИнтерфейсов.
//
// Параметры:
// Идентификатор - Строка - идентификатор записи кэша
// ТипДанных - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов.
// ПараметрыПолучения - Строка - массив параметров сериализованный в XML для передачи в метод
//  обновления кэша
// ВозвращатьУстаревшиеДанные - Булево - флаг определяющий необходимость ожидания обновления
//  данных в кэше перед возвратом значения, в случае обнаружения факта их устаревания.
//  Истина - всегда использовать данные из кэша, если они там есть. Ложь - ожидать
//  обновления данных кэша, в случае обнаружения факта устаревания данных.
//
// Возвращаемое значение:
// Произвольный.
//
Функция ПолучитьДанныеКэшаВерсий(Знач Идентификатор, Знач ТипДанных, 
		Знач ПараметрыПолучения, Знач ИспользоватьУстаревшиеДанные = Истина) Экспорт
	
	ПараметрыПолучения = ОбщегоНазначения.ЗначениеИзСтрокиXML(ПараметрыПолучения);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено()
		И ОбщегоНазначенияПовтИсп.СеансЗапущенБезРазделителей()
		И ОбщегоНазначения.ИспользованиеРазделителяСеанса() Тогда
		
		ВосстановитьРазделение = Истина;
		
		ОбщегоНазначения.УстановитьРазделениеСеанса(Ложь);
		
	Иначе
		
		ВосстановитьРазделение = Ложь;
		
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	КэшПрограммныхИнтерфейсов.ДатаОбновления КАК ДатаОбновления,
	|	КэшПрограммныхИнтерфейсов.Данные КАК Данные,
	|	КэшПрограммныхИнтерфейсов.ТипДанных КАК ТипДанных
	|ИЗ
	|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК КэшПрограммныхИнтерфейсов
	|ГДЕ
	|	КэшПрограммныхИнтерфейсов.Идентификатор = &Идентификатор
	|	И КэшПрограммныхИнтерфейсов.ТипДанных = &ТипДанных";
	Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
	Запрос.УстановитьПараметр("ТипДанных", ТипДанных);
	
	НачатьТранзакцию();
	// Не устанавливаем управляемую блокировку что бы другие сеансы могли изменять значение пока эта транзакция активна
	Результат = Запрос.Выполнить();
	ЗафиксироватьТранзакцию();
	
	ИмяМетодаЗадания = "ОбщегоНазначения.ОбновитьДанныеКэшаВерсий";
	КлючЗадания = Идентификатор + "|" + XMLСтрока(ТипДанных);
	ПараметрыЗадания = Новый Массив;
	ПараметрыЗадания.Добавить(Идентификатор);
	ПараметрыЗадания.Добавить(ТипДанных);
	ПараметрыЗадания.Добавить(ПараметрыПолучения);
	
	ОтборЗаданий = Новый Структура;
	ОтборЗаданий.Вставить("ИмяМетода", ИмяМетодаЗадания);
	ОтборЗаданий.Вставить("Ключ", КлючЗадания);
	ОтборЗаданий.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
	
	Выборка = Неопределено;
	
	Если Результат.Пустой() Тогда
		
		Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
			ОбщегоНазначения.ОбновитьДанныеКэшаВерсий(Идентификатор, ТипДанных, ПараметрыПолучения);
		Иначе
			Задания = ФоновыеЗадания.ПолучитьФоновыеЗадания(ОтборЗаданий);
			Если Задания.Количество() = 0 Тогда
				// Запустим новое
				Задание = ФоновыеЗадания.Выполнить(ИмяМетодаЗадания, ПараметрыЗадания, КлючЗадания);
			Иначе
				Задание = Задания[0];
			КонецЕсли;
			
			Попытка
				// Дождемся завершения
				Задание.ОжидатьЗавершения();
			Исключение
				Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Задание.УникальныйИдентификатор);
				Если Задание.ИнформацияОбОшибке <> Неопределено Тогда
					ЗаписьЖурналаРегистрации("ОбновлениеКэшаВерсий", УровеньЖурналаРегистрации.Ошибка, , ,
						ПодробноеПредставлениеОшибки(Задание.ИнформацияОбОшибке));
					ВызватьИсключение(КраткоеПредставлениеОшибки(Задание.ИнформацияОбОшибке));
				Иначе
					ЗаписьЖурналаРегистрации("ОбновлениеКэшаВерсий", УровеньЖурналаРегистрации.Ошибка, , ,
						ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
					ВызватьИсключение;
				КонецЕсли;
			КонецПопытки;
		КонецЕсли;
		
		НачатьТранзакцию();
		Результат = Запрос.Выполнить();
		ЗафиксироватьТранзакцию();
		
		Если Результат.Пустой() Тогда
			ШаблонСообщения = НСтр("ru = 'Ошибка при обновлении данных кэша версий. 
				|Идентификатор записи: %1
				|ТипДанных информации: %2'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ШаблонСообщения, Идентификатор, ТипДанных);
				
			Если ВосстановитьРазделение Тогда
				ОбщегоНазначения.УстановитьРазделениеСеанса(Истина);
			КонецЕсли;
			ВызватьИсключение(ТекстСообщения);
		КонецЕсли;
	Иначе
		
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		Если ОбщегоНазначения.ЗаписьКэшаВерсийУстарела(Выборка) Тогда
			Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
				ОбщегоНазначения.ОбновитьДанныеКэшаВерсий(Идентификатор, ТипДанных, ПараметрыПолучения);
				Выборка = Неопределено;
			Иначе
				// Данные устарели
				Задания = ФоновыеЗадания.ПолучитьФоновыеЗадания(ОтборЗаданий);
				Если Задания.Количество() = 0 Тогда
					// Запустим новое
					Задание = ФоновыеЗадания.Выполнить(ИмяМетодаЗадания, ПараметрыЗадания, КлючЗадания);
				Иначе
					Задание = Задания[0];
				КонецЕсли;
				
				Если НЕ ИспользоватьУстаревшиеДанные Тогда
					Попытка
						// Дождемся завершения
						Задание.ОжидатьЗавершения();
					Исключение
						Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Задание.УникальныйИдентификатор);
						Если Задание.ИнформацияОбОшибке <> Неопределено Тогда
							ЗаписьЖурналаРегистрации("ОбновлениеКэшаВерсий", УровеньЖурналаРегистрации.Ошибка, , ,
								ПодробноеПредставлениеОшибки(Задание.ИнформацияОбОшибке));
							ВызватьИсключение(КраткоеПредставлениеОшибки(Задание.ИнформацияОбОшибке));
						Иначе
							ЗаписьЖурналаРегистрации("ОбновлениеКэшаВерсий", УровеньЖурналаРегистрации.Ошибка, , ,
								ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
							ВызватьИсключение;
						КонецЕсли;
					КонецПопытки;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Выборка = Неопределено Тогда
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
	КонецЕсли;
	
	Если ВосстановитьРазделение Тогда
		ОбщегоНазначения.УстановитьРазделениеСеанса(Истина);
	КонецЕсли;
	
	Возврат Выборка.Данные.Получить();
	
КонецФункции
